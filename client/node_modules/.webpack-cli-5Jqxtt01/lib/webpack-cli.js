"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const { pathToFileURL } = require("url");
const util = require("util");
const { program, Option } = require("commander");
const WEBPACK_PACKAGE_IS_CUSTOM = !!process.env.WEBPACK_PACKAGE;
const WEBPACK_PACKAGE = WEBPACK_PACKAGE_IS_CUSTOM
    ? process.env.WEBPACK_PACKAGE
    : "webpack";
const WEBPACK_DEV_SERVER_PACKAGE_IS_CUSTOM = !!process.env.WEBPACK_DEV_SERVER_PACKAGE;
const WEBPACK_DEV_SERVER_PACKAGE = WEBPACK_DEV_SERVER_PACKAGE_IS_CUSTOM
    ? process.env.WEBPACK_DEV_SERVER_PACKAGE
    : "webpack-dev-server";
class WebpackCLI {
    constructor() {
        this.colors = this.createColors();
        this.logger = this.getLogger();
        // Initialize program
        this.program = program;
        this.program.name("webpack");
        this.program.configureOutput({
            writeErr: this.logger.error,
            outputError: (str, write) => write(`Error: ${this.capitalizeFirstLetter(str.replace(/^error:/, "").trim())}`),
        });
    }
    isMultipleCompiler(compiler) {
        return compiler.compilers;
    }
    isPromise(value) {
        return typeof value.then === "function";
    }
    isFunction(value) {
        return typeof value === "function";
    }
    capitalizeFirstLetter(str) {
        if (typeof str !== "string") {
            return "";
        }
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    toKebabCase(str) {
        return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    }
    createColors(useColor) {
        const { createColors, isColorSupported } = require("colorette");
        let shouldUseColor;
        if (useColor) {
            shouldUseColor = useColor;
        }
        else {
            shouldUseColor = isColorSupported;
        }
        return Object.assign(Object.assign({}, createColors({ useColor: shouldUseColor })), { isColorSupported: shouldUseColor });
    }
    getLogger() {
        return {
            error: (val) => console.error(`[webpack-cli] ${this.colors.red(util.format(val))}`),
            warn: (val) => console.warn(`[webpack-cli] ${this.colors.yellow(val)}`),
            info: (val) => console.info(`[webpack-cli] ${this.colors.cyan(val)}`),
            success: (val) => console.log(`[webpack-cli] ${this.colors.green(val)}`),
            log: (val) => console.log(`[webpack-cli] ${val}`),
            raw: (val) => console.log(val),
        };
    }
    checkPackageExists(packageName) {
        if (process.versions.pnp) {
            return true;
        }
        let dir = __dirname;
        do {
            try {
                if (fs.statSync(path.join(dir, "node_modules", packageName)).isDirectory()) {
                    return true;
                }
            }
            catch (_error) {
                // Nothing
            }
        } while (dir !== (dir = path.dirname(dir)));
        // https://github.com/nodejs/node/blob/v18.9.1/lib/internal/modules/cjs/loader.js#L1274
        for (const internalPath of require("module").globalPaths) {
            try {
                if (fs.statSync(path.join(internalPath, packageName)).isDirectory()) {
                    return true;
                }
            }
            catch (_error) {
                // Nothing
            }
        }
        return false;
    }
    getAvailablePackageManagers() {
        const { sync } = require("cross-spawn");
        const installers = ["npm", "yarn", "pnpm"];
        const hasPackageManagerInstalled = (packageManager) => {
            try {
                sync(packageManager, ["--version"]);
                return packageManager;
            }
            catch (err) {
                return false;
            }
        };
        const availableInstallers = installers.filter((installer) => hasPackageManagerInstalled(installer));
        if (!availableInstallers.length) {
            this.logger.error("No package manager found.");
            process.exit(2);
        }
        return availableInstallers;
    }
    getDefaultPackageManager() {
        const { sync } = require("cross-spawn");
        const hasLocalNpm = fs.existsSync(path.resolve(process.cwd(), "package-lock.json"));
        if (hasLocalNpm) {
            return "npm";
        }
        const hasLocalYarn = fs.existsSync(path.resolve(process.cwd(), "yarn.lock"));
        if (hasLocalYarn) {
            return "yarn";
        }
        const hasLocalPnpm = fs.existsSync(path.resolve(process.cwd(), "pnpm-lock.yaml"));
        if (hasLocalPnpm) {
            return "pnpm";
        }
        try {
            // the sync function below will fail if npm is not installed,
            // an error will be thrown
            if (sync("npm", ["--version"])) {
                return "npm";
            }
        }
        catch (e) {
            // Nothing
        }
        try {
            // the sync function below will fail if yarn is not installed,
            // an error will be thrown
            if (sync("yarn", ["--version"])) {
                return "yarn";
            }
        }
        catch (e) {
            // Nothing
        }
        try {
            // the sync function below will fail if pnpm is not installed,
            // an error will be thrown
            if (sync("pnpm", ["--version"])) {
                return "pnpm";
            }
        }
        catch (e) {
            this.logger.error("No package manager found.");
            process.exit(2);
        }
    }
    async doInstall(packageName, options = {}) {
        const packageManager = this.getDefaultPackageManager();
        if (!packageManager) {
            this.logger.error("Can't find package manager");
            process.exit(2);
        }
        if (options.preMessage) {
            options.preMessage();
        }
        const prompt = ({ message, defaultResponse, stream }) => {
            const readline = require("readline");
            const rl = readline.createInterface({
                input: process.stdin,
                output: stream,
            });
            return new Promise((resolve) => {
                rl.question(`${message} `, (answer) => {
                    // Close the stream
                    rl.close();
                    const response = (answer || defaultResponse).toLowerCase();
                    // Resolve with the input response
                    if (response === "y" || response === "yes") {
                        resolve(true);
                    }
                    else {
                        resolve(false);
                    }
                });
            });
        };
        // yarn uses 'add' command, rest npm and pnpm both use 'install'
        const commandArguments = [packageManager === "yarn" ? "add" : "install", "-D", packageName];
        const commandToBeRun = `${packageManager} ${commandArguments.join(" ")}`;
        let needInstall;
        try {
            needInstall = await prompt({
                message: `[webpack-cli] Would you like to install '${this.colors.green(packageName)}' package? (That will run '${this.colors.green(commandToBeRun)}') (${this.colors.yellow("Y/n")})`,
                defaultResponse: "Y",
                stream: process.stderr,
            });
        }
        catch (error) {
            this.logger.error(error);
            process.exit(error);
        }
        if (needInstall) {
            const { sync } = require("cross-spawn");
            try {
                sync(packageManager, commandArguments, { stdio: "inherit" });
            }
            catch (error) {
                this.logger.error(error);
                process.exit(2);
            }
            return packageName;
        }
        process.exit(2);
    }
    async tryRequireThenImport(module, handleError = true, moduleType = "unknown") {
        let result;
        switch (moduleType) {
            case "unknown": {
                try {
                    result = require(module);
                }
                catch (error) {
                    const dynamicImportLoader = require("./utils/dynamic-import-loader")();
                    if ((error.code === "ERR_REQUIRE_ESM" ||
                        process.env.WEBPACK_CLI_FORCE_LOAD_ESM_CONFIG) &&
                        pathToFileURL &&
                        dynamicImportLoader) {
                        const urlForConfig = pathToFileURL(module);
                        result = await dynamicImportLoader(urlForConfig);
                        result = result.default;
                        return result;
                    }
                    if (handleError) {
                        this.logger.error(error);
                        process.exit(2);
                    }
                    else {
                        throw error;
                    }
                }
                break;
            }
            case "commonjs": {
                try {
                    result = require(module);
                }
                catch (error) {
                    if (handleError) {
                        this.logger.error(error);
                        process.exit(2);
                    }
                    else {
                        throw error;
                    }
                }
                break;
            }
            case "esm": {
                try {
                    const dynamicImportLoader = require("./utils/dynamic-import-loader")();
                    if (pathToFileURL && dynamicImportLoader) {
                        const urlForConfig = pathToFileURL(module);
                        result = await dynamicImportLoader(urlForConfig);
                        result = result.default;
                        return result;
                    }
                }
                catch (error) {
                    if (handleError) {
                        this.logger.error(error);
                        process.exit(2);
                    }
                    else {
                        throw error;
                    }
                }
                break;
            }
        }
        // For babel and other, only commonjs
        if (result && typeof result === "object" && "default" in result) {
            result = result.default || {};
        }
        return result || {};
    }
    loadJSONFile(pathToFile, handleError = true) {
        let result;
        try {
            result = require(pathToFile);
        }
        catch (error) {
            if (handleError) {
                this.logger.error(error);
                process.exit(2);
            }
            else {
                throw error;
            }
        }
        return result;
    }
    getInfoOptions() {
        return [
            {
                name: "output",
                alias: "o",
                configs: [
                    {
                        type: "string",
                    },
                ],
                description: "To get the output in a specified format ( accept json or markdown )",
                helpLevel: "minimum",
            },
            {
                name: "additional-package",
                alias: "a",
                configs: [{ type: "string" }],
                multiple: true,
                description: "Adds additional packages to the output",
                helpLevel: "minimum",
            },
        ];
    }
    async getInfoOutput(options) {
        let { output } = options;
        const envinfoConfig = {};
        if (output) {
            // Remove quotes if exist
            output = output.replace(/['"]+/g, "");
            switch (output) {
                case "markdown":
                    envinfoConfig["markdown"] = true;
                    break;
                case "json":
                    envinfoConfig["json"] = true;
                    break;
                default:
                    this.logger.error(`'${output}' is not a valid value for output`);
                    process.exit(2);
            }
        }
        const defaultInformation = {
            Binaries: ["Node", "Yarn", "npm"],
            Browsers: [
                "Brave Browser",
                "Chrome",
                "Chrome Canary",
                "Edge",
                "Firefox",
                "Firefox Developer Edition",
                "Firefox Nightly",
                "Internet Explorer",
                "Safari",
                "Safari Technology Preview",
            ],
            Monorepos: ["Yarn Workspaces", "Lerna"],
            System: ["OS", "CPU", "Memory"],
            npmGlobalPackages: ["webpack", "webpack-cli", "webpack-dev-server"],
        };
        let defaultPackages = ["webpack", "loader", "@webpack-cli/"];
        if (typeof options.additionalPackage !== "undefined") {
            defaultPackages = [...defaultPackages, ...options.additionalPackage];
        }
        defaultInformation.npmPackages = `{${defaultPackages.map((item) => `*${item}*`).join(",")}}`;
        const envinfo = await this.tryRequireThenImport("envinfo", false);
        let info = await envinfo.run(defaultInformation, envinfoConfig);
        info = info.replace(/npmPackages/g, "Packages");
        info = info.replace(/npmGlobalPackages/g, "Global Packages");
        return info;
    }
    async makeCommand(commandOptions, options, action) {
        const alreadyLoaded = this.program.commands.find((command) => command.name() === commandOptions.name.split(" ")[0] ||
            command.aliases().includes(commandOptions.alias));
        if (alreadyLoaded) {
            return;
        }
        const command = this.program.command(commandOptions.name, {
            hidden: commandOptions.hidden,
            isDefault: commandOptions.isDefault,
        });
        if (commandOptions.description) {
            command.description(commandOptions.description, commandOptions.argsDescription);
        }
        if (commandOptions.usage) {
            command.usage(commandOptions.usage);
        }
        if (Array.isArray(commandOptions.alias)) {
            command.aliases(commandOptions.alias);
        }
        else {
            command.alias(commandOptions.alias);
        }
        if (commandOptions.pkg) {
            command.pkg = commandOptions.pkg;
        }
        else {
            command.pkg = "webpack-cli";
        }
        const { forHelp } = this.program;
        let allDependenciesInstalled = true;
        if (commandOptions.dependencies && commandOptions.dependencies.length > 0) {
            for (const dependency of commandOptions.dependencies) {
                const isPkgExist = this.checkPackageExists(dependency);
                if (isPkgExist) {
                    continue;
                }
                else if (!isPkgExist && forHelp) {
                    allDependenciesInstalled = false;
                    continue;
                }
                let skipInstallation = false;
                // Allow to use `./path/to/webpack.js` outside `node_modules`
                if (dependency === WEBPACK_PACKAGE && WEBPACK_PACKAGE_IS_CUSTOM) {
                    skipInstallation = true;
                }
                // Allow to use `./path/to/webpack-dev-server.js` outside `node_modules`
                if (dependency === WEBPACK_DEV_SERVER_PACKAGE && WEBPACK_DEV_SERVER_PACKAGE_IS_CUSTOM) {
                    skipInstallation = true;
                }
                if (skipInstallation) {
                    continue;
                }
                await this.doInstall(dependency, {
                    preMessage: () => {
                        this.logger.error(`For using '${this.colors.green(commandOptions.name.split(" ")[0])}' command you need to install: '${this.colors.green(dependency)}' package.`);
                    },
                });
            }
        }
        if (options) {
            if (typeof options === "function") {
                if (forHelp && !allDependenciesInstalled && commandOptions.dependencies) {
                    command.description(`${commandOptions.description} To see all available options you need to install ${commandOptions.dependencies
                        .map((dependency) => `'${dependency}'`)
                        .join(", ")}.`);
                    options = [];
                }
                else {
                    options = await options();
                }
            }
            for (const option of options) {
                this.makeOption(command, option);
            }
        }
        command.action(action);
        return command;
    }
    makeOption(command, option) {
        let mainOption;
        let negativeOption;
        const flagsWithAlias = ["devtool", "output-path", "target", "watch"];
        if (flagsWithAlias.includes(option.name)) {
            option.alias = option.name[0];
        }
        if (option.configs) {
            let needNegativeOption = false;
            let negatedDescription;
            const mainOptionType = new Set();
            for (const config of option.configs) {
                switch (config.type) {
                    case "reset":
                        mainOptionType.add(Boolean);
                        break;
                    case "boolean":
                        if (!needNegativeOption) {
                            needNegativeOption = true;
                            negatedDescription = config.negatedDescription;
                        }
                        mainOptionType.add(Boolean);
                        break;
                    case "number":
                        mainOptionType.add(Number);
                        break;
                    case "string":
                    case "path":
                    case "RegExp":
                        mainOptionType.add(String);
                        break;
                    case "enum": {
                        let hasFalseEnum = false;
                        for (const value of config.values || []) {
                            switch (typeof value) {
                                case "string":
                                    mainOptionType.add(String);
                                    break;
                                case "number":
                                    mainOptionType.add(Number);
                                    break;
                                case "boolean":
                                    if (!hasFalseEnum && value === false) {
                                        hasFalseEnum = true;
                                        break;
                                    }
                                    mainOptionType.add(Boolean);
                                    break;
                            }
                        }
                        if (!needNegativeOption) {
                            needNegativeOption = hasFalseEnum;
                            negatedDescription = config.negatedDescription;
                        }
                    }
                }
            }
            mainOption = {
                flags: option.alias ? `-${option.alias}, --${option.name}` : `--${option.name}`,
                valueName: option.valueName || "value",
                description: option.description || "",
                type: mainOptionType,
                multiple: option.multiple,
                defaultValue: option.defaultValue,
            };
            if (needNegativeOption) {
                negativeOption = {
                    flags: `--no-${option.name}`,
                    description: negatedDescription || option.negatedDescription || `Negative '${option.name}' option.`,
                };
            }
        }
        else {
            mainOption = {
                flags: option.alias ? `-${option.alias}, --${option.name}` : `--${option.name}`,
                valueName: option.valueName || "value",
                description: option.description || "",
                type: option.type
                    ? new Set(Array.isArray(option.type) ? option.type : [option.type])
                    : new Set([Boolean]),
                multiple: option.multiple,
                defaultValue: option.defaultValue,
            };
            if (option.negative) {
                negativeOption = {
                    flags: `--no-${option.name}`,
                    description: option.negatedDescription
                        ? option.negatedDescription
                        : `Negative '${option.name}' option.`,
                };
            }
        }
        if (mainOption.type.size > 1 && mainOption.type.has(Boolean)) {
            mainOption.flags = `${mainOption.flags} [${mainOption.valueName || "value"}${mainOption.multiple ? "..." : ""}]`;
        }
        else if (mainOption.type.size > 0 && !mainOption.type.has(Boolean)) {
            mainOption.flags = `${mainOption.flags} <${mainOption.valueName || "value"}${mainOption.multiple ? "..." : ""}>`;
        }
        if (mainOption.type.size === 1) {
            if (mainOption.type.has(Number)) {
                let skipDefault = true;
                const optionForCommand = new Option(mainOption.flags, mainOption.description)
                    .argParser((value, prev = []) => {
                    if (mainOption.defaultValue && mainOption.multiple && skipDefault) {
                        prev = [];
                        skipDefault = false;
                    }
                    return mainOption.multiple
                        ? [].concat(prev).concat(Number(value))
                        : Number(value);
                })
                    .default(mainOption.defaultValue);
                optionForCommand.helpLevel = option.helpLevel;
                command.addOption(optionForCommand);
            }
            else if (mainOption.type.has(String)) {
                let skipDefault = true;
                const optionForCommand = new Option(mainOption.flags, mainOption.description)
                    .argParser((value, prev = []) => {
                    if (mainOption.defaultValue && mainOption.multiple && skipDefault) {
                        prev = [];
                        skipDefault = false;
                    }
                    return mainOption.multiple ? [].concat(prev).concat(value) : value;
                })
                    .default(mainOption.defaultValue);
                optionForCommand.helpLevel = option.helpLevel;
                command.addOption(optionForCommand);
            }
            else if (mainOption.type.has(Boolean)) {
                const optionForCommand = new Option(mainOption.flags, mainOption.description).default(mainOption.defaultValue);
                optionForCommand.helpLevel = option.helpLevel;
                command.addOption(optionForCommand);
            }
            else {
                const optionForCommand = new Option(mainOption.flags, mainOption.description)
                    .argParser(Array.from(mainOption.type)[0])
                    .default(mainOption.defaultValue);
                optionForCommand.helpLevel = option.helpLevel;
                command.addOption(optionForCommand);
            }
        }
        else if (mainOption.type.size > 1) {
            let skipDefault = true;
            const optionForCommand = new Option(mainOption.flags, mainOption.description, mainOption.defaultValue)
                .argParser((value, prev = []) => {
                if (mainOption.defaultValue && mainOption.multiple && skipDefault) {
                    prev = [];
                    skipDefault = false;
                }
                if (mainOption.type.has(Number)) {
                    const numberValue = Number(value);
                    if (!isNaN(numberValue)) {
                        return mainOption.multiple
                            ? [].concat(prev).concat(numberValue)
                            : numberValue;
                    }
                }
                if (mainOption.type.has(String)) {
                    return mainOption.multiple ? [].concat(prev).concat(value) : value;
                }
                return value;
            })
                .default(mainOption.defaultValue);
            optionForCommand.helpLevel = option.helpLevel;
            command.addOption(optionForCommand);
        }
        else if (mainOption.type.size === 0 && negativeOption) {
            const optionForCommand = new Option(mainOption.flags, mainOption.description);
            // Hide stub option
            optionForCommand.hideHelp();
            optionForCommand.helpLevel = option.helpLevel;
            command.addOption(optionForCommand);
        }
        if (negativeOption) {
            const optionForCommand = new Option(negativeOption.flags, negativeOption.description);
            optionForCommand.helpLevel = option.helpLevel;
            command.addOption(optionForCommand);
        }
    }
    getBuiltInOptions() {
        if (this.builtInOptionsCache) {
            return this.builtInOptionsCache;
        }
        const builtInFlags = [
            // For configs
            {
                name: "config",
                alias: "c",
                configs: [
                    {
                        type: "string",
                    },
                ],
                multiple: true,
                valueName: "pathToConfigFile",
                description: 'Provide path to one or more webpack configuration files to process, e.g. "./webpack.config.js".',
                helpLevel: "minimum",
            },
            {
                name: "config-name",
                configs: [
                    {
                        type: "string",
                    },
                ],
                multiple: true,
                valueName: "name",
                description: "Name(s) of particular configuration(s) to use if configuration file exports an array of multiple configurations.",
                helpLevel: "minimum",
            },
            {
                name: "merge",
                alias: "m",
                configs: [
                    {
                        type: "enum",
                        values: [true],
                    },
                ],
                description: "Merge two or more configurations using 'webpack-merge'.",
                helpLevel: "minimum",
            },
            {
                name: "disable-interpret",
                configs: [
                    {
                        type: "enum",
                        values: [true],
                    },
                ],
                description: "Disable interpret for loading the config file.",
                helpLevel: "minimum",
            },
            // Complex configs
            {
                name: "env",
                type: (value, previous = {}) => {
                    // This ensures we're only splitting by the first `=`
                    const [allKeys, val] = value.split(/=(.+)/, 2);
                    const splitKeys = allKeys.split(/\.(?!$)/);
                    let prevRef = previous;
                    splitKeys.forEach((someKey, index) => {
                        // https://github.com/webpack/webpack-cli/issues/3284
                        if (someKey.endsWith("=")) {
                            // remove '=' from key
                            someKey = someKey.slice(0, -1);
                            // @ts-expect-error we explicitly want to set it to undefined
                            prevRef[someKey] = undefined;
                            return;
                        }
                        if (!prevRef[someKey]) {
                            prevRef[someKey] = {};
                        }
                        if (typeof prevRef[someKey] === "string") {
                            prevRef[someKey] = {};
                        }
                        if (index === splitKeys.length - 1) {
                            if (typeof val === "string") {
                                prevRef[someKey] = val;
                            }
                            else {
                                prevRef[someKey] = true;
                            }
                        }
                        prevRef = prevRef[someKey];
                    });
                    return previous;
                },
                multiple: true,
                description: 'Environment variables passed to the configuration when it is a function, e.g. "myvar" or "myvar=myval".',
                helpLevel: "minimum",
            },
            {
                name: "node-env",
                configs: [
                    {
                        type: "string",
                    },
                ],
                multiple: false,
                description: "Sets process.env.NODE_ENV to the specified value.",
                helpLevel: "minimum",
            },
            {
                name: "define-process-env-node-env",
                configs: [
                    {
                        type: "string",
                    },
                ],
                multiple: false,
                description: "Sets process.env.NODE_ENV to the specified value. (Currently an alias for `--node-env`).",
                helpLevel: "verbose",
            },
            // Adding more plugins
            {
                name: "analyze",
                configs: [
                    {
                        type: "enum",
                        values: [true],
                    },
                ],
                multiple: false,
                description: "It inv
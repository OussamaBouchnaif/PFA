{"version":3,"names":["_core","require","_helperPluginUtils","_template","DefineAccessorHelper","template","expression","ast","_compact","_default","exports","default","declare","api","options","_api$assumption","assertVersion","setComputedProperties","assumption","loose","pushComputedProps","pushComputedPropsLoose","pushComputedPropsSpec","buildDefineAccessor","state","obj","prop","type","kind","key","computed","t","isIdentifier","stringLiteral","name","fn","getValue","helper","availableHelper","addHelper","file","get","id","scope","generateUidIdentifier","push","init","set","cloneNode","callExpression","isObjectProperty","value","isObjectMethod","functionExpression","params","body","generator","async","pushAssign","objId","expressionStatement","assignmentExpression","memberExpression","isLiteral","info","computedProps","initPropExpression","length","CHUNK_LENGTH_CAP","currentChunk","computedPropsChunks","chunk","single","node","toComputedKey","visitor","ObjectExpression","exit","path","parent","hasComputed","properties","initProps","foundComputed","isSpreadElement","generateUidIdentifierBasedOnNode","objectExpression","variableDeclaration","variableDeclarator","replaceWith","replaceWithMultiple"],"sources":["../src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport template from \"@babel/template\";\nimport type { Scope } from \"@babel/traverse\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\ntype PropertyInfo = {\n  scope: Scope;\n  objId: t.Identifier;\n  body: t.Statement[];\n  computedProps: t.ObjectMember[];\n  initPropExpression: t.ObjectExpression;\n  state: PluginPass;\n};\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var DefineAccessorHelper = template.expression.ast`\n    function (type, obj, key, fn) {\n      var desc = { configurable: true, enumerable: true };\n      desc[type] = fn;\n      return Object.defineProperty(obj, key, desc);\n    }\n  `;\n  // @ts-expect-error undocumented _compact node property\n  DefineAccessorHelper._compact = true;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const setComputedProperties =\n    api.assumption(\"setComputedProperties\") ?? options.loose;\n\n  const pushComputedProps = setComputedProperties\n    ? pushComputedPropsLoose\n    : pushComputedPropsSpec;\n\n  function buildDefineAccessor(\n    state: PluginPass,\n    obj: t.Expression,\n    prop: t.ObjectMethod,\n  ) {\n    const type = prop.kind as \"get\" | \"set\";\n    const key =\n      !prop.computed && t.isIdentifier(prop.key)\n        ? t.stringLiteral(prop.key.name)\n        : prop.key;\n    const fn = getValue(prop);\n    if (process.env.BABEL_8_BREAKING) {\n      return t.callExpression(state.addHelper(\"defineAccessor\"), [\n        t.stringLiteral(type),\n        obj,\n        key,\n        fn,\n      ]);\n    } else {\n      let helper: t.Identifier;\n      if (state.availableHelper(\"defineAccessor\")) {\n        helper = state.addHelper(\"defineAccessor\");\n      } else {\n        // Fallback for @babel/helpers <= 7.20.6, ma